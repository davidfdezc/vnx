# dhcp.pm
#
# This file is a plugin of VNX package.
#
# Authors: Jorge Somavilla, Miguel Ferrer, Francisco José Martín (VNUML version, 2009)
#          David Fernández (VNX version, 2011)
# Coordinated by: David Fernández (david@dit.upm.es)
#
# Copyright (C) 2011,   DIT-UPM
#           Departamento de Ingenieria de Sistemas Telematicos
#           Universidad Politecnica de Madrid
#           SPAIN
#           
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
# An online copy of the licence can be found at http://www.gnu.org/copyleft/gpl.html
#
package dhcp;

@ISA = qw(Exporter);
@EXPORT = qw(
  initPlugin
  getFiles
  getCommands
  finalizePlugin 
);


###########################################################
# Modules to import
###########################################################
use strict;
use Net::Netmask;
use XML::DOM;               # XML management library
use File::Basename;         # File management library
use Switch;
use Socket;                 # To resolve hostnames to IPs
use XML::DOM::ValParser;    # To check DTD
use VNX::FileChecks;                    # To use get_abs_path
use VNX::CheckSemantics;                # To use validate_xml


###########################################################
# Global variables 
###########################################################

my $pcf_dom;


###########################################################
# Plugin functions
###########################################################

#
# initPlugin
#
# To be called always, just before starting procesing the scenario specification
#
# Arguments:
# - the operation mode ("t","x","d" or "P")
# - the plugin configuration file
#
# Returns:
# - an error message or 0 if all is ok
#
#

sub initPlugin {
    
    my $self = shift;   
    my $mode = shift;
    my $conf = shift;  # Absolute filename of PCF. Empty if PCF not defined 
    
    print "dhcp-plugin> initPlugin (mode=$mode; conf=$conf)\n";

    # Validate PCF with XSD language definition 
    my $error = validate_xml ($conf);
    print "*************** error = $error \n";
    if (! $error ) {
        my $parser = new XML::DOM::Parser;
        my $dom_tree = $parser->parsefile($conf);
        $pcf_dom = $dom_tree->getElementsByTagName("dhcp_conf")->item(0);
    } 

    return $error;
}

#
# getFiles
#
# To be called during "x" mode, for each vm in the scenario
#
# Arguments:
# - vm name
# - seq command sequence
# - files_dir
#
# Returns:
# - a hashname which keys are absolute pathnames of files in vm filesystem and
#   values of the pathname of the file in the host filesystem. The file in the
#   host filesytesm is removed after VNUML processed it, so temporal files in 
#   /tmp are preferable)
#
#
sub getFiles{

    my $self      = shift;
    my $vm_name   = shift;
    my $files_dir = shift;
    my $seq       = shift;
    
    print "dhcp-plugin> getFiles (vm=$vm_name, seq=$seq)\n";
    my %files;
    
    if (($seq eq "on_boot") || ($seq eq "dhcp-on_boot") ) { 
    
        my $vm_tag_list=$pcf_dom->getElementsByTagName("vm");
        
        for (my $m=0; $m<$vm_tag_list->getLength; $m++){
            
            my $vm = $vm_tag_list->item($m);
            
            if ($vm->getAttribute("name") eq $vm_name){
                
                my $type = $vm->getAttribute("type");
    
                switch ($type) {
    
                    case ["dhcp3","dhcp3-isc"] {
    
                        my $etc_dir ="/etc/dhcp3/";
                        if ($type eq "dhcp3-isc") {
                            $etc_dir = "/etc/dhcp/";
                        }
    
                        my $server_tag_list = $vm->getElementsByTagName("server");
                        my $numservers = $server_tag_list->getLength;
                        if ( $numservers == 1 ) {
    
                            # open filehandle to create dhcpd.conf file
                            my $server_file = $files_dir . "/${vm_name}_server.conf";
                            chomp( my $date = `date` );
                            open( SERVER, ">$server_file" ) or $files{"ERROR"} = "Cannot open $server_file file";
    
                            # server.conf file defaults
                            print SERVER "# server.conf file generated by dhcp.pm VNX plugin at $date\n\n";
                            print SERVER "ddns-update-style none;\n";
                            print SERVER "default-lease-time 120;\n";
                            print SERVER "max-lease-time 120;\n";
                            #print SERVER "log-facility local7;\n\n";
    
                            # extract configuration from subnet blocks in dhcp_conf.xml
                            my $server = $server_tag_list->item(0);
                            my $subnet_tag_list = $server->getElementsByTagName("subnet");
                            my $numsubnets = $subnet_tag_list->getLength;
    
                            for ( my $ns=0; $ns < $numsubnets ; $ns++ ) {
                                my $subnet = $subnet_tag_list->item($ns);
                                my $ip_tag_list = $subnet->getElementsByTagName("ip");
                                my $numip = $ip_tag_list->getLength;
    
                                # subnet declaration
                                my $ip = $ip_tag_list->item($0);
                                my $subnetmask = $ip->getAttribute("mask");
                                my $subnetbaseip = $ip->getFirstChild->getData;
                                my $block = new Net::Netmask("$subnetbaseip"."/"."$subnetmask");
                                
                                my $baseip = $block->base();
                                my $mask = $block->mask();
                                print SERVER "subnet $baseip netmask $mask {\n";
    
                                # extract ip ranges in subnet
                                my $range_tag_list = $subnet->getElementsByTagName("range");
                                my $numranges = $range_tag_list->getLength;
                                
                                for ( my $nr = 0; $nr < $numranges ; $nr++ ) {
                                    my $range = $range_tag_list->item($nr);
                                    
                                    my $first_tag_list = $range->getElementsByTagName("first");
                                    my $first = $first_tag_list->item(0);
                                    my $first_ip = $first->getFirstChild->getData;
                                    
                                    my $last_tag_list = $range->getElementsByTagName("last");
                                    my $last = $last_tag_list->item(0);
                                    my $last_ip  = $last->getFirstChild->getData;
                                    
                                    print SERVER "  range $first_ip $last_ip;\n";
                                }
    
                                # extract routers in subnet (if any)
                                my $router_tag_list = $subnet->getElementsByTagName("router");
                                my $numrouters = $router_tag_list->getLength;
                                
                                if ( $numrouters > 0 ) {
                                    print SERVER "  option routers";
                                    for ( my $nr = 0; $nr < $numrouters ; $nr++ ) {
                                        if ( $nr > 0 ) {
                                            print SERVER ",";
                                        }
                                        my $router_tag = $router_tag_list->item($nr);
                                        my $router = $router_tag->getFirstChild->getData;
                                        print SERVER " $router";
                                    }
                                    print SERVER ";\n";
                                }
    
                                # extract dns in subnet (if any)
                                my $dns_tag_list = $subnet->getElementsByTagName("dns");
                                my $numdns = $dns_tag_list->getLength;
                                if ( $numdns > 0 ) {
                                    print SERVER "  option domain-name-servers";
                                    for ( my $nd = 0; $nd < $numdns ; $nd++ ) {
                                        if ( $nd > 0 ) {
                                            print SERVER ",";
                                        }
                                        my $dns_tag = $dns_tag_list->item($nd);
                                        my $dns = $dns_tag->getFirstChild->getData;
                                        print SERVER " $dns";
                                    }
                                    print SERVER ";\n";
                                }
    
                                # extract domain in subnet (if specified)
                                my $domain_tag_list = $subnet->getElementsByTagName("domain");
                                my $numdomains = $domain_tag_list->getLength;
                                if ( $numdomains == 1 ) {
                                    my $domain_tag = $domain_tag_list->item(0);
                                    my $domain = $domain_tag->getFirstChild->getData;
                                    print SERVER "  option domain-name \"$domain\";\n";
                                }
    
                                # end subnet declaration in configuration file
                                print SERVER "}\n\n";
    
                                # extract hosts in subnet (if any)
                                my $host_tag_list = $subnet->getElementsByTagName("host");
                                my $numhosts = $host_tag_list->getLength;
                                for ( my $nh = 0; $nh < $numhosts ; $nh++ ) {
                                    my $host_tag  = $host_tag_list->item($nh);
                                    my $hostname = $host_tag->getAttribute("name");
                                    my $hostmac  = $host_tag->getAttribute("mac");
                                    my $hostip   = $host_tag->getAttribute("ip");
    
                                    # ignore unmatching host declarations
                                    if ( $block->match($hostip) ) {
                                        print SERVER "host $hostname {\n  hardware ethernet $hostmac;\n  fixed-address $hostip;\n}\n\n";
                                    }
                                }
    
                            }
                            close(SERVER);
                            $server_file =~ s#$files_dir/##;  # Eliminate the directory to make the filenames relative 
                            $files{"${etc_dir}dhcpd.conf,,,644"} = $server_file;
                        }
    
                        my $relay_tag_list = $vm->getElementsByTagName("relay");
                        my $numrelays    = $relay_tag_list->getLength;
                        if ( $numrelays == 1 ) {
    
                            # Build file /etc/default/dhcp3-relay.conf
                            my $relay_file = $files_dir . "/${vm_name}_relay.conf";
                            chomp( my $date = `date` );
                            open( RELAY, ">$relay_file" ) or $files{"ERROR"} = "Cannot open $relay_file file";
                            print RELAY "# relay.conf file generated by dhcp.pm VNX plugin at $date\n";
                            print RELAY "SERVERS=\"";
                            my $relay = $relay_tag_list->item(0);
                            my $toserver_tag_list = $relay->getElementsByTagName("toserver");
                            my $numtoservers = $toserver_tag_list->getLength;
    
                            for ( my $nt = 0; $nt < $numtoservers ; $nt++ ) {
                                my $toserver_tag  = $toserver_tag_list->item($nt);
                                my $toserverData = $toserver_tag->getFirstChild->getData;
                                print RELAY "$toserverData ";
                            }
    
                            print RELAY "\"\n";
                            close(RELAY);
                            $relay_file =~ s#$files_dir/##;  # Eliminate the directory to make the filenames relative 
                            $files{"/etc/default/dhcp3-relay,,,644"} = $relay_file;
                        }
    
                        my $client_tag_list = $vm->getElementsByTagName("client");
                        my $numclients = $client_tag_list->getLength;
                        if ( $numclients == 1 ) {
                            # Build file dhclient.conf
                            my $client_file = $files_dir . "/${vm_name}_client.conf";
                            chomp( my $date = `date` );
                            open( CLIENT, ">$client_file" ) or $files{"ERROR"} = "Cannot open $client_file file";
                            print CLIENT "# Configuration file for /sbin/dhclient, which is included in Debian's dhcp3-client package.\n";
                            print CLIENT "# client.conf file generated by dhcp.pm VNX plugin at $date\n\n";
                            print CLIENT "send host-name \"<hostname>\";\n";
                            print CLIENT "request subnet-mask, broadcast-address, time-offset, routers, domain-name, domain-name-servers, domain-search, host-name, netbios-name-servers, netbios-scope, interface-mtu;\n";
                            print CLIENT "retry 10;\n";
                            close(CLIENT);
                            $client_file =~ s#$files_dir/##;  # Eliminate the directory to make the filenames relative 
                            $files{"${etc_dir}dhclient.conf,,,644"} = $client_file;
                            
                        }
                    } else {
                       $files{"ERROR"} = "Unknown type value $type in vm $vm\n";
                    } 
                } # switch
            
            } # if
        }
    }
    return %files;
          
}

sub getFiles{

    my $self      = shift;
    my $vm_name   = shift;
    my $files_dir = shift;
    my $seq       = shift;
    
    print "dhcp-plugin> getFiles (vm=$vm_name, seq=$seq)\n";
    my %files;
    
    if (($seq eq "on_boot") || ($seq eq "dhcp-on_boot") ) { 
    
        my $vm_tag_list=$pcf_dom->getElementsByTagName("vm");
        
        for (my $m=0; $m<$vm_tag_list->getLength; $m++){
            
            my $vm = $vm_tag_list->item($m);
            
            if ($vm->getAttribute("name") eq $vm_name){
	            
	            my $type = $vm->getAttribute("type");
	
	            switch ($type) {
	
	                case ["dhcp3","dhcp3-isc"] {
	
	                    my $etc_dir ="/etc/dhcp3/";
                        if ($type eq "dhcp3-isc") {
                            $etc_dir = "/etc/dhcp/";
                        }
	
	                    my $server_tag_list = $vm->getElementsByTagName("server");
	                    my $numservers = $server_tag_list->getLength;
	                    if ( $numservers == 1 ) {
	
	                        # open filehandle to create dhcpd.conf file
	                        my $server_file = $files_dir . "/${vm_name}_server.conf";
	                        chomp( my $date = `date` );
	                        open( SERVER, ">$server_file" ) or $files{"ERROR"} = "Cannot open $server_file file";
	
	                        # server.conf file defaults
	                        print SERVER "# server.conf file generated by dhcp.pm VNX plugin at $date\n\n";
	                        print SERVER "ddns-update-style none;\n";
	                        print SERVER "default-lease-time 120;\n";
	                        print SERVER "max-lease-time 120;\n";
	                        #print SERVER "log-facility local7;\n\n";
	
	                        # extract configuration from subnet blocks in dhcp_conf.xml
	                        my $server = $server_tag_list->item(0);
	                        my $subnet_tag_list = $server->getElementsByTagName("subnet");
	                        my $numsubnets = $subnet_tag_list->getLength;
	
	                        for ( my $ns=0; $ns < $numsubnets ; $ns++ ) {
	                            my $subnet = $subnet_tag_list->item($ns);
	                            my $ip_tag_list = $subnet->getElementsByTagName("ip");
	                            my $numip = $ip_tag_list->getLength;
	
	                            # subnet declaration
	                            my $ip = $ip_tag_list->item($0);
	                            my $subnetmask = $ip->getAttribute("mask");
	                            my $subnetbaseip = $ip->getFirstChild->getData;
	                            my $block = new Net::Netmask("$subnetbaseip"."/"."$subnetmask");
	                            
	                            my $baseip = $block->base();
	                            my $mask = $block->mask();
	                            print SERVER "subnet $baseip netmask $mask {\n";
	
	                            # extract ip ranges in subnet
	                            my $range_tag_list = $subnet->getElementsByTagName("range");
	                            my $numranges = $range_tag_list->getLength;
	                            
	                            for ( my $nr = 0; $nr < $numranges ; $nr++ ) {
	                                my $range = $range_tag_list->item($nr);
	                                
	                                my $first_tag_list = $range->getElementsByTagName("first");
	                                my $first = $first_tag_list->item(0);
	                                my $first_ip = $first->getFirstChild->getData;
	                                
	                                my $last_tag_list = $range->getElementsByTagName("last");
	                                my $last = $last_tag_list->item(0);
	                                my $last_ip  = $last->getFirstChild->getData;
	                                
	                                print SERVER "  range $first_ip $last_ip;\n";
	                            }
	
	                            # extract routers in subnet (if any)
	                            my $router_tag_list = $subnet->getElementsByTagName("router");
	                            my $numrouters = $router_tag_list->getLength;
	                            
	                            if ( $numrouters > 0 ) {
	                                print SERVER "  option routers";
	                                for ( my $nr = 0; $nr < $numrouters ; $nr++ ) {
	                                    if ( $nr > 0 ) {
	                                        print SERVER ",";
	                                    }
	                                    my $router_tag = $router_tag_list->item($nr);
	                                    my $router = $router_tag->getFirstChild->getData;
	                                    print SERVER " $router";
	                                }
	                                print SERVER ";\n";
	                            }
	
	                            # extract dns in subnet (if any)
	                            my $dns_tag_list = $subnet->getElementsByTagName("dns");
	                            my $numdns = $dns_tag_list->getLength;
	                            if ( $numdns > 0 ) {
	                                print SERVER "  option domain-name-servers";
	                                for ( my $nd = 0; $nd < $numdns ; $nd++ ) {
	                                    if ( $nd > 0 ) {
	                                        print SERVER ",";
	                                    }
	                                    my $dns_tag = $dns_tag_list->item($nd);
	                                    my $dns = $dns_tag->getFirstChild->getData;
	                                    print SERVER " $dns";
	                                }
	                                print SERVER ";\n";
	                            }
	
	                            # extract domain in subnet (if specified)
	                            my $domain_tag_list = $subnet->getElementsByTagName("domain");
	                            my $numdomains = $domain_tag_list->getLength;
	                            if ( $numdomains == 1 ) {
	                                my $domain_tag = $domain_tag_list->item(0);
	                                my $domain = $domain_tag->getFirstChild->getData;
	                                print SERVER "  option domain-name \"$domain\";\n";
	                            }
	
	                            # end subnet declaration in configuration file
	                            print SERVER "}\n\n";
	
	                            # extract hosts in subnet (if any)
	                            my $host_tag_list = $subnet->getElementsByTagName("host");
	                            my $numhosts = $host_tag_list->getLength;
	                            for ( my $nh = 0; $nh < $numhosts ; $nh++ ) {
	                                my $host_tag  = $host_tag_list->item($nh);
	                                my $hostname = $host_tag->getAttribute("name");
	                                my $hostmac  = $host_tag->getAttribute("mac");
	                                my $hostip   = $host_tag->getAttribute("ip");
	
	                                # ignore unmatching host declarations
	                                if ( $block->match($hostip) ) {
	                                    print SERVER "host $hostname {\n  hardware ethernet $hostmac;\n  fixed-address $hostip;\n}\n\n";
	                                }
	                            }
	
	                        }
	                        close(SERVER);
	                        $server_file =~ s#$files_dir/##;  # Eliminate the directory to make the filenames relative 
	                        $files{"${etc_dir}dhcpd.conf,,,644"} = $server_file;
	                    }
	
	                    my $relay_tag_list = $vm->getElementsByTagName("relay");
	                    my $numrelays    = $relay_tag_list->getLength;
	                    if ( $numrelays == 1 ) {
	
	                        # Build file /etc/default/dhcp3-relay.conf
	                        my $relay_file = $files_dir . "/${vm_name}_relay.conf";
	                        chomp( my $date = `date` );
	                        open( RELAY, ">$relay_file" ) or $files{"ERROR"} = "Cannot open $relay_file file";
	                        print RELAY "# relay.conf file generated by dhcp.pm VNX plugin at $date\n";
	                        print RELAY "SERVERS=\"";
	                        my $relay = $relay_tag_list->item(0);
	                        my $toserver_tag_list = $relay->getElementsByTagName("toserver");
	                        my $numtoservers = $toserver_tag_list->getLength;
	
	                        for ( my $nt = 0; $nt < $numtoservers ; $nt++ ) {
	                            my $toserver_tag  = $toserver_tag_list->item($nt);
	                            my $toserverData = $toserver_tag->getFirstChild->getData;
	                            print RELAY "$toserverData ";
	                        }
	
	                        print RELAY "\"\n";
	                        close(RELAY);
                            $relay_file =~ s#$files_dir/##;  # Eliminate the directory to make the filenames relative 
	                        $files{"/etc/default/dhcp3-relay,,,644"} = $relay_file;
	                    }
	
	                    my $client_tag_list = $vm->getElementsByTagName("client");
	                    my $numclients = $client_tag_list->getLength;
	                    if ( $numclients == 1 ) {
	                        # Build file dhclient.conf
	                        my $client_file = $files_dir . "/${vm_name}_client.conf";
	                        chomp( my $date = `date` );
	                        open( CLIENT, ">$client_file" ) or $files{"ERROR"} = "Cannot open $client_file file";
	                        print CLIENT "# Configuration file for /sbin/dhclient, which is included in Debian's dhcp3-client package.\n";
	                        print CLIENT "# client.conf file generated by dhcp.pm VNX plugin at $date\n\n";
	                        print CLIENT "send host-name \"<hostname>\";\n";
	                        print CLIENT "request subnet-mask, broadcast-address, time-offset, routers, domain-name, domain-name-servers, domain-search, host-name, netbios-name-servers, netbios-scope, interface-mtu;\n";
	                        print CLIENT "retry 10;\n";
	                        close(CLIENT);
                            $client_file =~ s#$files_dir/##;  # Eliminate the directory to make the filenames relative 
	                        $files{"${etc_dir}dhclient.conf,,,644"} = $client_file;
	                        
	                    }
	                } else {
	                   $files{"ERROR"} = "Unknown type value $type in vm $vm\n";
	                } 
	            } # switch
	        
            } # if
        }
    }
    return %files;
          
}

#
# getCommands
#
# To be called during "-x" mode, for each vm in the scenario
#
# Arguments:
# - vm name
# - seq command sequence
# 
# Returns:
# - list of commands to execute in the virtual machine after <exec> processing
#
#    
sub getCommands{
    
    my $self = shift;
    my $vm_name = shift;
    my $seq = shift;
    
    print "dhcp-plugin> getCommands (vm=$vm_name, seq=$seq)\n";
    
    my @commands;
    my $type;

    my $vm_tag_list = $pcf_dom->getElementsByTagName("vm");
    
    for (my $m=0 ; $m < $vm_tag_list->getLength ; $m++) {

        my $vm = $vm_tag_list->item($m);
        my $virtualm_name = $vm->getAttribute("name");
        
        if ( $vm->getAttribute("name") eq $vm_name ) {
            
            $type = $vm->getAttribute("type");
            
            switch ($type) {

                case ["dhcp3","dhcp3-isc"] {
                	
                	my $dhcp_server_cmd ="/etc/init.d/dhcp3-server";
                	my $dhcp_relay_cmd  ="/etc/init.d/dhcp3-relay";
					if ($type eq "dhcp3-isc") {
						$dhcp_server_cmd = "/etc/init.d/isc-dhcp-server";
						$dhcp_relay_cmd  = "/etc/init.d/isc-dhcp-relay";						
					}
					
		            my $server_tag_list = $vm->getElementsByTagName("server");
		            my $numservers      = $server_tag_list->getLength;
		            my $relay_tag_list  = $vm->getElementsByTagName("relay");
		            my $numrelays       = $relay_tag_list->getLength;
		            my $client_tag_list = $vm->getElementsByTagName("client");
		            my $numclients      = $client_tag_list->getLength;
		
		            switch ($seq){

		                case ["on_boot", "start", "dhcp-start"]{    
		                    # Start server, relay and clients in the virtual machine, if any
		                    unshift( @commands, "" );
		                    if ( $numservers == 1 ) {
		                        push( @commands, "$dhcp_server_cmd start" );
		                    }
		                    if ( $numrelays == 1 ) {
		                        push( @commands, "$dhcp_relay_cmd start" );
		                    }
		                    if (!($numclients == 0)) {
		                        my $client = $client_tag_list->item(0);
		                        my $if_tag_list = $client->getElementsByTagName("if");
		                        my $numif = $if_tag_list->getLength;
		                        for (my $ni=0; $ni<$numif ; $ni++) {
		                            my $if_tag  = $if_tag_list->item($ni);
		                            my $if_data = $if_tag->getFirstChild->getData;
		                            if (!($if_data == 0)) {
		                                push(@commands,"dhclient eth"."$if_data");
		                            }
		                        }
		                    }
		                    
		                }
		                case ["restart","dhcp-restart"]{
		                    # Restart server, relay and clients in the virtual machine, if any  
		                    unshift( @commands, "" );
		                    if ( $numservers == 1 ) {
		                        push( @commands, "$dhcp_server_cmd restart" );
		                    }
		                    if ( $numrelays == 1 ) {
		                        push( @commands, "$dhcp_relay_cmd restart" );
		                    }
		                    if (!($numclients == 0)) {
		                        my $client = $client_tag_list->item(0);
		                        my $if_tag_list = $client->getElementsByTagName("if");
		                        my $numif = $if_tag_list->getLength;
		                        for (my $ni=0; $ni<$numif ; $ni++) {
		                            my $if_tag  = $if_tag_list->item($ni);
		                            my $if_data = $if_tag->getFirstChild->getData;
		                            if (!($if_data == 0)) {
		                                push(@commands,"dhclient -r");
		                                push(@commands,"killall dhclient");
		                                push(@commands,"dhclient eth"."$if_data");
		                            }
		                        }
		                    }
		                    
		                }
		                case ["stop","dhcp-stop"]{  
		                    # Stop server and relay in the virtual machine, if any
		                    unshift( @commands, "" );
		                    if ( $numservers == 1 ) {
		                        push( @commands, "$dhcp_server_cmd stop" );
		                    }
		                    if ( $numrelays == 1 ) {
		                        push( @commands, "$dhcp_relay_cmd stop" );
		                    }
		                    if (!($numclients == 0)) {
		                        my $client = $client_tag_list->item(0);
		                        my $if_tag_list = $client->getElementsByTagName("if");
		                        my $numif = $if_tag_list->getLength;
		                        for (my $ni=0; $ni<$numif ; $ni++) {
		                            my $if_tag  = $if_tag_list->item($ni);
		                            my $if_data = $if_tag->getFirstChild->getData;
		                            if (!($if_data == 0)) {
		                                push(@commands,"dhclient -r");
		                                push(@commands,"killall dhclient");
		                            }
		                        }
		                    }
		                    
		                }
		                case ("dhcp-server-start"){
		                    # Start the server in the virtual machine. Return error if there isn't any. 
		                    if ( $numservers == 0 ) {
		                        unshift( @commands, "$vm is not configured as a dhcp server. Choose the appropriate virtual machine with flag -M name" );
		                    }
		                    else {
		                        unshift( @commands, "" );
		                        push( @commands, "$dhcp_server_cmd start" );
		                    }
		                }
		                case ("dhcp-relay-start"){
		                    # Start the relay in the virtual machine. Return error if there isn't any.
		                    if ( $numrelays == 0 ) {
		                        unshift( @commands, "$vm is not configured as a dhcp relay. Choose the appropriate virtual machine with flag -M name" );
		                    }
		                    else {
		                        unshift( @commands, "" );
		                        push( @commands, "$dhcp_relay_cmd start" );
		                    }                                       
		                }
		                case ("dhcp-client-start"){
		                    # Start the clients in the virtual machine. Return error if there aren't any.
		                    if ( $numclients == 0 ) {
		                        unshift( @commands, "$vm is not configured as a dhcp client. Choose the appropriate virtual machine with flag -M name" );
		                    }
		                    else {
		                        unshift(@commands, "" );
		                        my $client = $client_tag_list->item(0);
		                        my $if_tag_list = $client->getElementsByTagName("if");
		                        my $numif = $if_tag_list->getLength;
		                        for (my $ni=0; $ni<$numif ; $ni++) {
		                            my $if_tag  = $if_tag_list->item($ni);
		                            my $if_data = $if_tag->getFirstChild->getData;
		                            if (!($if_data == 0)) {
		                                push(@commands,"dhclient eth"."$if_data");
		                            }
		                        }
		    
		                    }
		                }
		                case ("dhcp-server-restart"){
		                    # Restart the server in the virtual machine. Return error if there isn't any. 
		                    if ( $numservers == 0 ) {
		                        unshift( @commands, "$vm is not configured as a dhcp server. Choose the appropriate virtual machine with flag -M name" );
		                    }
		                    else {
		                        unshift( @commands, "" );
		                        push( @commands, "$dhcp_server_cmd restart" );
		                    }
		                }
		                case ("dhcp-relay-restart"){
		                    # Restart the relay in the virtual machine. Return error if there isn't any.
		                    if ( $numrelays == 0 ) {
		                        unshift( @commands, "$vm is not configured as a dhcp relay. Choose the appropriate virtual machine with flag -M name" );
		                    }
		                    else {
		                        unshift( @commands, "" );
		                        push( @commands, "$dhcp_relay_cmd restart" );
		                    }                                       
		                }
		                
		                case ("dhcp-client-restart"){
		                    # Start the clients in the virtual machine. Return error if there aren't any.
		                    if ( $numclients == 0 ) {
		                        unshift( @commands, "$vm is not configured as a dhcp client. Choose the appropriate virtual machine with flag -M name" );
		                    }
		                    else {
		                        unshift(@commands, "" );
		                        my $client = $client_tag_list->item(0);
		                        my $if_tag_list = $client->getElementsByTagName("if");
		                        my $numif = $if_tag_list->getLength;
		                        for (my $ni=0; $ni<$numif ; $ni++) {
		                            my $if_tag  = $if_tag_list->item($ni);
		                            my $if_data = $if_tag->getFirstChild->getData;
		                            if (!($if_data == 0)) {
		                                push(@commands,"dhclient -r");
		                                push(@commands,"killall dhclient");
		                                push(@commands,"dhclient eth"."$if_data");
		                            }
		                        }
		    
		                    }
		                }
		                
		                case ("dhcp-server-stop"){
		                    # Stop the server in the virtual machine. Return error if there isn't any. 
		                    if ( $numservers == 0 ) {
		                        unshift( @commands, "$vm is not configured as a dhcp server. Choose the appropriate virtual machine with flag -M name" );
		                    }
		                    else {
		                        unshift( @commands, "" );
		                        push( @commands, "$dhcp_server_cmd stop" );
		                    }
		                
		                }
		                case ("dhcp-relay-stop"){
		                    # Stop the relay in the virtual machine. Return error if there isn't any. 
		                    if ( $numrelays == 0 ) {
		                        unshift( @commands, "$vm is not configured as a dhcp relay. Choose the appropriate virtual machine with flag -M name" );
		                    }
		                    else {
		                        unshift( @commands, "" );
		                        push( @commands, "$dhcp_relay_cmd stop" );
		                    }
		                
		                }
		                
		                case ("dhcp-client-stop"){
		                    # Start the clients in the virtual machine. Return error if there aren't any.
		                    if ( $numclients == 0 ) {
		                        unshift( @commands, "$vm is not configured as a dhcp client. Choose the appropriate virtual machine with flag -M name" );
		                    }
		                    else {
		                        unshift(@commands, "" );
		                        my $client = $client_tag_list->item(0);
		                        my $if_tag_list = $client->getElementsByTagName("if");
		                        my $numif = $if_tag_list->getLength;
		                        for (my $ni=0; $ni<$numif ; $ni++) {
		                            my $if_tag  = $if_tag_list->item($ni);
		                            my $if_data = $if_tag->getFirstChild->getData;
		                            if (!($if_data == 0)) {
		                                push(@commands,"dhclient -r");
		                                push(@commands,"killall dhclient");
		                            }
		                        }
		    
		                    }
		                }
		                
		                case ("dhcp-server-force-reload"){
		                    # Force reload of the server in the virtual machine. Return error if there isn't any. 
		                    if ( $numservers == 0 ) {
		                        unshift( @commands, "$vm is not configured as a dhcp server. Choose the appropriate virtual machine with flag -M name" );
		                    }
		                    else {
		                        unshift( @commands, "" );
		                        push( @commands, "$dhcp_server_cmd force-reload" );
		                    }
		                
		                }
		                case ("dhcp-relay-force-reload"){
		                    # Force reload of the relay in the virtual machine. Return error if there isn't any. 
		                    if ( $numservers == 0 ) {
		                        unshift( @commands, "$vm is not configured as a dhcp relay. Choose the appropriate virtual machine with flag -M name" );
		                    }
		                    else {
		                        unshift( @commands, "" );
		                        push( @commands, "$dhcp_relay_cmd force-reload" );
		                    }
		                
		                }
		                case ("on_shutdown"){
                            # Force reload of the relay in the virtual machine. Return error if there isn't any. 
		                    unshift( @commands, "" );
		
		                    if ( $numservers == 1 ) {
		                        push( @commands, "$dhcp_server_cmd stop" );
		                    }
		
		                    if ( $numrelays == 1 ) {
		                        push( @commands, "$dhcp_relay_cmd stop" );
		                    }
                        
                        } else {
		                    unshift( @commands, "\nYour choice \"$seq\" is not a recognized command (yet).\nAvailable commands: start, stop, restart, dhcp-start, dhcp-stop, dhcp-restart, dhcp-server-start, dhcp-server-stop, dhcp-server-restart, dhcp-server-force-reload, dhcp-relay-start, dhcp-relay-stop, dhcp-relay-restart, dhcp-relay-force-reload, dhcp-client-start.\n" );
		                }
		            }

                }
                else {
                    unshift( @commands, "Unknown type value $type in vm $vm\n");
                }
            }
        }
    }        
    return @commands;
    
}

#
# finalizePlugin
#
# To be called always, just before ending the procesing the scenario specification
#
# Arguments:
# - none
#
# Returns:
# - none
#
sub finalizePlugin {
    
    print "dhcp-plugin> finalizePlugin ()\n";

}

###########################################################
# Internal functions
###########################################################


1;