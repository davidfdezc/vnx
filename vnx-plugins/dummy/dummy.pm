# Ospf.pm
#
# The ospfd plugin

package ospf;

@ISA = qw(Exporter);
@EXPORT = qw(
  initPlugin
  getBootFiles
  getBootCommands
  getExecFiles
  getExecCommands
  getExecVmsUsed
  getShutdownFiles
  getShutdownCommands
  finalizePlugin 
);

###########################################################
# Modules import
###########################################################

use strict;
use XML::DOM;                           # XML management library
use File::Basename;                     # File management library

use Switch;

use Socket;                             # To resolve hostnames to IPs

use XML::DOM::ValParser;                # To check DTD


###########################################################
# Global variables 
###########################################################

my $globalNode;
my $valid_fail;

###########################################################
# Subroutines   
###########################################################

###########################################################
# Create plugin
#
# To be called always, just before starting procesing the scenario specification
#
# Arguments:
# - the operation mode ("define", "create","execute","shutdown" or "destroy")
# - the plugin configuration file
#
# Returns:
# - an error message or 0 if all is ok
#
#
###########################################################

sub initPlugin{
    
    my $self = shift;   
    my $mode = shift;
    my $conf = shift;
    
    print "ospf-plugin> createPlugin (mode=$mode; conf=$conf)\n";

    my $error;
    
    eval{
        $error = &checkConfigFile($conf);
    };
    
    if ($@){
        $error = $@;
    }
    return $error;
}

###########################################################
# getBootFiles
#
# To be called during "create" mode, for each vm in the scenario
#
# Arguments:
# - vm_name, virtual machine name
# - files_dir, directory where the files returned have to be copied
#
# Returns:
# - a hashname whose:
#      + keys are absolute pathnames of files in vm filesystem and
#      + values are the relative pathname of the file in the host filesystem. The file in the
#   host filesytesm is removed after VNUML processed it, so temporal files in 
#   /tmp are preferable)
###########################################################

sub getBootFiles{
    
    my $self      = shift;
    my $vm_name   = shift;
    my $files_dir = shift;
    
    print "ospf-plugin> getBootFiles (vm=$vm_name, files_dir=$files_dir)\n";
    my %files;
    
    my $virtualmList=$globalNode->getElementsByTagName("vm");
    my $longitud = $virtualmList->getLength;
    
    for (my $m=0; $m<$longitud; $m++){
        
        my $virtualm = $virtualmList->item($m);
        my $virtualm_name = $virtualm->getAttribute("name");
        
        if ($virtualm_name eq $vm_name){
            #my $zebra_file = "/tmp/$vm_name"."_zebra.conf";
            #my $ospfd_file = "/tmp/$vm_name"."_ospfd.conf";
            my $zebra_file = $files_dir . "/$vm_name"."_zebra.conf";
            my $ospfd_file = $files_dir . "/$vm_name"."_ospfd.conf";
            #print "ospf-plugin> getBootFiles zebra_file=$zebra_file\n";
            
            my $zebraTagList = $virtualm->getElementsByTagName("zebra");
            my $zebraTag = $zebraTagList->item($0);
            my $zebra_hostname = $zebraTag->getAttribute("hostname");
            my $zebra_password = $zebraTag->getAttribute("password");
            
            chomp(my $date = `date`);
                    
            # Write the content of zebra.conf file
            open(ZEBRA, "> $zebra_file") or $files{"ERROR"} = "Cannot open $zebra_file file";
            print ZEBRA "! zebra.conf file generated by ospfd.pm VNUML plugin at $date\n";
            print ZEBRA "hostname $zebra_hostname\n";
            print ZEBRA "password $zebra_password\n";
            print ZEBRA "log file /var/log/zebra/zebra.log\n";          
            close (ZEBRA);
                
            # Write the content of ospfd.conf file
            open(OSPFD, "> $ospfd_file") or $files{"ERROR"} = "Cannot open $ospfd_file file";
            print OSPFD "! ospfd.conf file generated by ospfd.pm VNUML plugin at $date\n";
            print OSPFD "hostname $zebra_hostname\n";
            print OSPFD "password $zebra_password\n";
            print OSPFD "log file /var/log/zebra/ospfd.log\n!\n";
            print OSPFD "router ospf\n";
            
            my $networkTagList = $virtualm->getElementsByTagName("network");
            my $longitudNetwork = $networkTagList->getLength;
            for (my $n=0; $n<$longitudNetwork; $n++){
                my $networkTag = $networkTagList->item($n);
                my $ipTagList = $networkTag->getElementsByTagName("ip");
                
                my $ipTag = $ipTagList->item($0);
                my $ipMask = $ipTag->getAttribute("mask");
                my $ipData = $ipTag->getFirstChild->getData;
                
                my $areaTagList = $networkTag->getElementsByTagName("area");
                my $areaTag = $areaTagList->item($0);
                my $areaData = $areaTag->getFirstChild->getData;
                
                print OSPFD " network $ipData/$ipMask area $areaData\n";
            }
            print OSPFD "!\n";          
            close (OSPFD);  
            
            # Directory test: DELETE
            system "mkdir $files_dir/kk";
            system "mkdir $files_dir/kk/d1";
            system "touch $files_dir/kk/f1";
            system "touch $files_dir/kk/f2";
            system "touch $files_dir/kk/d1/f1";

            # Fill the hash with the files created
            $zebra_file =~ s#$files_dir/##;  # Eliminate the directory to make the filenames relative 
            $ospfd_file =~ s#$files_dir/##;   
            $files{"/etc/quagga/zebra.conf,quagga,quagga,644"} = $zebra_file;
            $files{"/etc/quagga/ospfd.conf,quagga,,644"} = $ospfd_file;
            $files{"/root/tmp"} = "kk";
        }
        
    
    }
    
    return %files;
}

# getBootCommands
#
# To be called during "-t" mode, for each vm in the scenario
#
# Arguments:
# - vm name
# 
# Returns:
# - list of commands to execute in the virtual machine at booting time
#
sub getBootCommands{

    my $self      = shift;
    my $vm_name   = shift;
    
    my @commands;

    print "ospf-plugin> getBootCommands (vm=$vm_name)\n";

    # Return code (OK)
    unshift (@commands, "");

    push (@commands, "touch /root/file-created-by-getBootCommands");

    return @commands;
}


# deprecated
=BEGIN
sub execVmsToUse {

    my $self = shift;
    my $seq = shift;

    print "ospf-plugin> execVmsToUse (seq=$seq)\n";

    return;  # Delete. It is just to test the behavior when not implemented
    

    # The plugin has nothing to do for VMs with sequences other than
    # start, restart or stop, so in that case it returns an empty list
    unless ($seq eq "start" || $seq eq "ospf-start" || $seq eq "restart" || 
            $seq eq "ospf-restart" || $seq eq "stop" || $seq eq "ospf-stop" || 
            $seq eq "redoconf" || $seq eq "ospf-redoconf") {
        return ();
    }
    
    # Return the list of virtual machines included in plugin extended config file
    my @vm_list = ();
    
    my $virtualmList=$globalNode->getElementsByTagName("vm");
    my $longitud = $virtualmList->getLength;
    
    for (my $m=0; $m<$longitud; $m++){
        
        my $virtualm = $virtualmList->item($m);
        push (@vm_list,$virtualm->getAttribute("name"));
    }
    
    return @vm_list;
    
}
=END
=cut


###########################################################
# getExecFiles
#
# To be called during "x" mode, for each vm in the scenario
#
# Arguments:
# - vm name
# - seq command sequence
# - files_dir
#
# Returns:
# - a hashname which keys are absolute pathnames of files in vm filesystem and
#   values of the pathname of the file in the host filesystem. The file in the
#   host filesytesm is removed after VNUML processed it, so temporal files in 
#   /tmp are preferable)
#
###########################################################
sub getExecFiles{

    my $self = shift;
    my $vm_name = shift;
    my $files_dir = shift;
    my $seq = shift;
    
    print "ospf-plugin> getExecFiles (vm=$vm_name, seq=$seq)\n";
    my %files;
    
    if (($seq eq "redoconf") || ($seq eq "ospf-redoconf")){ 
    

        my $virtualmList=$globalNode->getElementsByTagName("vm");
        my $longitud = $virtualmList->getLength;
        
        for (my $m=0; $m<$longitud; $m++){
            
            my $virtualm = $virtualmList->item($m);
            my $virtualm_name = $virtualm->getAttribute("name");
            
            if ($virtualm_name eq $vm_name){
                #my $zebra_file = "/tmp/$vm_name"."_zebra.conf";
                #my $ospfd_file = "/tmp/$vm_name"."_ospfd.conf";
                my $zebra_file = $files_dir . "/$vm_name"."_zebra.conf";
                my $ospfd_file = $files_dir . "/$vm_name"."_ospfd.conf";
                print "ospf-plugin> getExecFiles zebra_file=$zebra_file\n";             
                print "ospf-plugin> getExecFiles ospfd_file=$ospfd_file\n";             
                
                my $zebraTagList = $virtualm->getElementsByTagName("zebra");
                my $zebraTag = $zebraTagList->item($0);
                my $zebra_hostname = $zebraTag->getAttribute("hostname");
                my $zebra_password = $zebraTag->getAttribute("password");
                
                chomp(my $date = `date`);
                        
                open(ZEBRA, ">$zebra_file") or $files{"ERROR"} = "Cannot open $zebra_file file";
                print ZEBRA "! zebra.conf file generated by ospfd.pm VNUML plugin at $date\n";
                print ZEBRA "hostname $zebra_hostname\n";
                print ZEBRA "password $zebra_password\n";
                print ZEBRA "log file /var/log/zebra/zebra.log\n";          
                close (ZEBRA);
                    
                open(OSPFD, ">$ospfd_file") or $files{"ERROR"} = "Cannot open $ospfd_file file";
                print OSPFD "! ospfd.conf file generated by ospfd.pm VNUML plugin at $date\n";
                print OSPFD "hostname $zebra_hostname\n";
                print OSPFD "password $zebra_password\n";
                print OSPFD "log file /var/log/zebra/ospfd.log\n!\n";
                print OSPFD "router ospf\n";
                
                my $networkTagList = $virtualm->getElementsByTagName("network");
                my $longitudNetwork = $networkTagList->getLength;
                for (my $n=0; $n<$longitudNetwork; $n++){
                    my $networkTag = $networkTagList->item($n);
                    my $ipTagList = $networkTag->getElementsByTagName("ip");
                    
                    my $ipTag = $ipTagList->item($0);
                    my $ipMask = $ipTag->getAttribute("mask");
                    my $ipData = $ipTag->getFirstChild->getData;
                    
                    my $areaTagList = $networkTag->getElementsByTagName("area");
                    my $areaTag = $areaTagList->item($0);
                    my $areaData = $areaTag->getFirstChild->getData;
                    
                    print OSPFD " network $ipData/$ipMask area $areaData\n";
                }
                print OSPFD "!\n";          
                close (OSPFD);  
                    
            # Directory test: DELETE
            system "mkdir $files_dir/kk";
            system "mkdir $files_dir/kk/d1";
            system "touch $files_dir/kk/f1";
            system "touch $files_dir/kk/f2";
            system "touch $files_dir/kk/d1/f1";

                $zebra_file =~ s#$files_dir/##;  # Eliminate the directory to make the filenames relative 
                $ospfd_file =~ s#$files_dir/##;   
                $files{"/etc/quagga/zebra.conf,quagga,quagga,644"} = $zebra_file;
                $files{"/etc/quagga/ospfd.conf,quagga,,644"} = $ospfd_file;
            $files{"/root/tmp"} = "kk";
            }
        }
    
    }
    return %files;  
    
}

###########################################################
# getExecCommands
#
# To be called during "-x" mode, for each vm in the scenario
#
# Arguments:
# - vm name
# - seq command sequence
# 
# Returns:
# - list of commands to execute in the virtual machine after <exec> processing
###########################################################
    
sub getExecCommands{
    
    my $self = shift;
    my $vm_name = shift;
    my $seq = shift;
    
    print "ospf-plugin> getExecCommands (vm=$vm_name, seq=$seq)\n";
    my @commands;
    
    my $type;
    my $subtype;
    
    my $zebra_bin = "";
    my $ospfd_bin = "";
    
    
    my $virtualmList=$globalNode->getElementsByTagName("vm");
    my $longitud = $virtualmList->getLength;
    
    for (my $m=0; $m<$longitud; $m++){
        
        my $virtualm = $virtualmList->item($m);
        my $virtualm_name = $virtualm->getAttribute("name");
        
        if ( $vm_name eq $virtualm_name){
            $type = $virtualm->getAttribute("type");
            $subtype = $virtualm->getAttribute("subtype");
            my $zebraBinTagList = $virtualm->getElementsByTagName("zebra_bin");
            my $longitudZebra = $zebraBinTagList->getLength;
            if ($longitudZebra == 1){
                $zebra_bin =  $zebraBinTagList->item($0)->getFirstChild->getData;
            }
            my $ospfdBinTagList = $virtualm->getElementsByTagName("ospfd_bin");
            my $longitudOspfd = $ospfdBinTagList->getLength;
            if ($longitudOspfd == 1){
                $ospfd_bin =  $ospfdBinTagList->item($0)->getFirstChild->getData;
            }
            
            switch ($type) {
                case "quagga"{ 
                    switch ($subtype){
                        case "lib-install"{
                    
                            if ($zebra_bin eq ""){
                                $zebra_bin = "/usr/lib/quagga/zebra";
                            }
                            if ($ospfd_bin eq ""){
                                $ospfd_bin = "/usr/lib/quagga/ospfd";
                            }
                            unshift (@commands, "");
                        }
                        case "sbin-install"{
                    
                            if ($zebra_bin eq ""){
                                $zebra_bin = "/usr/sbin/zebra";
                            }
                            if ($ospfd_bin eq ""){
                                $ospfd_bin = "/usr/sbin/ospfd";
                            }
                            unshift (@commands, "");
                    
                        } else {
                            unshift (@commands, "Your choice $subtype is not a recognized subtype (yet)\n");
                        }
                    }
                } else {
                    unshift (@commands, "Your choice $type is not a recognized type (yet)\n");
                }
            }
    
            if (($seq eq "start") || ($seq eq "ospf-start")){
        
                push (@commands, "$zebra_bin -d");
                push (@commands, "$ospfd_bin -d");
                        
        
            }elsif(($seq eq "restart") || ($seq eq "ospf-restart")){
                
                push (@commands, "killall zebra");
                push (@commands, "killall ospfd");
        
                push (@commands, "$zebra_bin -d");
                push (@commands, "$ospfd_bin -d");
        
            }elsif(($seq eq "stop") || ($seq eq "ospf-stop")){
        
                push (@commands, "killall zebra");
                push (@commands, "killall ospfd");
        
            }
        }
    }
    
    return @commands;   
    
}

sub getShutdownFiles{
    
    my $self      = shift;
    my $vm_name   = shift;
    my $files_dir = shift;
    
    print "ospf-plugin> getShutdownFiles (vm=$vm_name, files_dir=$files_dir)\n";
    my %files;
    
    # Directory test: DELETE
    system "touch $files_dir/f1";
    system "touch $files_dir/f2";
    system "mkdir $files_dir/kk";
    system "mkdir $files_dir/kk/d1";
    system "touch $files_dir/kk/f1";
    system "touch $files_dir/kk/f2";
    system "touch $files_dir/kk/d1/f1";

    $files{"/root/shutdown/f1"} = "f1";
    $files{"/root/shutdown/f2"} = "f2";
    $files{"/root/tmp"} = "kk";
    return %files;  

}

sub getShutdownCommands{

    my $self = shift;
    my $vm   = shift;

    my @commands;
    print "ospf-plugin> getShutdownCommands ()\n";

    # Return code (OK)
    unshift (@commands, "");

    push (@commands, "touch /root/file-created-by-getShutdownCommands");

    return @commands;

}

# finalizePlugin
#
# To be called always, just before ending the procesing the scenario specification
#
# Arguments:
# - none
#
# Returns:
# - none
#
sub finalizePlugin{
    
    print "ospf-plugin> finalizePlugin ()\n";
    
}


#############################################################
#
# Checks existence and semantics in ospf conf file. 
# Currently this check consist in:
#
#   1. Configuration file exists.
#   2. Check DTD.
#
#############################################################

sub checkConfigFile{
    
    # 1. Configuration file exists.
    my $config_file = shift;
    open(FILEHANDLE, $config_file) or {
        return "cannot open config file $config_file\n",
    };
    close (FILEHANDLE);
    
    # 2. Check DTD
    my $parser = new XML::DOM::ValParser;
    my $dom_tree;
    $valid_fail = 0;
    eval {
        local $XML::Checker::FAIL = \&validation_fail;
        $dom_tree = $parser->parsefile($config_file);
    };

    if ($valid_fail) {
        return ("$config_file is not a well-formed OSPF plugin file\n");
    }

    $globalNode = $dom_tree->getElementsByTagName("ospf_conf")->item(0);
    
    return 0;   
}

sub validation_fail {
   my $code = shift;
   # To set flag
   $valid_fail = 1;
   # To print error message
   XML::Checker::print_error ($code, @_);
}

1;
    